n = 5000
mu = 0
sigma = 1
x <- rnorm(n, mu, sigma)
hist(x)
p <- ggplot()+aes(x)+geom_histogram(binwith = 1, colour = 'black',fill = '#1976D2')
p # you have to call the plot once you assign it to a variable
# ggplot gives more beautiful graph
# we can also fit the normal denstify function for this graph
p+stat_function(fun = dnorm, colour = 'red', args = list(mean = mu, sd = sigma, n = 5000))
set.seed(6000)
n = 5000
mu = 0
sigma = 1
x <- rnorm(n, mu, sigma)
hist(x)
curve(dnorm(x, mean(mu), sd(sigma)), add=TRUE, col="darkblue", lwd=2)
p <- ggplot()+aes(x)+geom_histogram(binwith = 1, colour = 'black',fill = '#1976D2')
p # you have to call the plot once you assign it to a variable
# ggplot gives more beautiful graph
# we can also fit the normal denstify function for this graph
p+stat_function(fun = dnorm, colour = 'red', args = list(mean = mu, sd = sigma))
set.seed(6000)
n = 5000
mu = 0
sigma = 1
x <- rnorm(n, mu, sigma)
hist(x)
curve(dnorm(x, mean(mu), sd(sigma)), add=TRUE, col="darkblue", lwd=2)
p <- ggplot()+aes(x)+geom_histogram(binwith = 1, colour = 'black',fill = '#1976D2')
p # you have to call the plot once you assign it to a variable
# ggplot gives more beautiful graph
# we can also fit the normal denstify function for this graph
p+stat_function(fun = dnorm, colour = 'red', args = list(mean = mu, sd = sigma))
set.seed(6000)
n = 5000
mu = 0
sigma = 1
x <- rnorm(n, mu, sigma)
hist(x)
curve(dnorm(x, mean=mu, sd=sigma), add=TRUE, col="darkblue", lwd=2)
p <- ggplot()+aes(x)+geom_histogram(binwith = 1, colour = 'black',fill = '#1976D2')
p # you have to call the plot once you assign it to a variable
# ggplot gives more beautiful graph
# we can also fit the normal denstify function for this graph
p+stat_function(fun = dnorm, colour = 'red', args = list(mean = mu, sd = sigma))
set.seed(6000)
n = 5000
mu = 0
sigma = 1
x <- rnorm(n, mu, sigma)
hist(x)
curve(dnorm(z, mean=mu, sd=sigma), add=TRUE, col="darkblue", lwd=2)
set.seed(6000)
n = 5000
mu = 0
sigma = 1
rv <- rnorm(n, mu, sigma)
hist(rv)
curve(dnorm(x, mean=mu, sd=sigma), add=TRUE, col="darkblue", lwd=2)
p <- ggplot()+aes(x)+geom_histogram(binwith = 1, colour = 'black',fill = '#1976D2')
p # you have to call the plot once you assign it to a variable
# ggplot gives more beautiful graph
# we can also fit the normal denstify function for this graph
p+stat_function(fun = dnorm, colour = 'red', args = list(mean = mu, sd = sigma))
set.seed(6000)
n = 5000
mu = 0
sigma = 1
x <- rnorm(n, mu, sigma)
hist(x)
curve(dnorm(x, mean=mu, sd=sigma), add=TRUE, col="darkblue", lwd=2,yaxt="n")
p <- ggplot()+aes(x)+geom_histogram(binwith = 1, colour = 'black',fill = '#1976D2')
p # you have to call the plot once you assign it to a variable
# ggplot gives more beautiful graph
# we can also fit the normal denstify function for this graph
p+stat_function(fun = dnorm, colour = 'red', args = list(mean = mu, sd = sigma))
set.seed(6000)
n = 5000
mu = 0
sigma = 1
x <- rnorm(n, mu, sigma)
hist(x)
curve(dnorm(x, mean=mu, sd=sigma), add=TRUE, col="darkblue", lwd=2)
p <- ggplot()+aes(x)+geom_histogram(binwith = 1, colour = 'black',fill = '#1976D2')
p # you have to call the plot once you assign it to a variable
# ggplot gives more beautiful graph
# we can also fit the normal denstify function for this graph
p+stat_function(fun = dnorm, colour = 'red', args = list(mean = mu, sd = sigma))
set.seed(6000)
n = 5000
mu = 0
sigma = 1
x <- rnorm(n, mu, sigma)
hist(x)
p1<-curve(dnorm(x, mean=mu, sd=sigma), add=TRUE, col="darkblue", lwd=2)
p2 <- ggplot()+aes(x)+geom_histogram(binwith = 1, colour = 'black',fill = '#1976D2')
p2 # you have to call the plot once you assign it to a variable
# ggplot gives more beautiful graph
# we can also fit the normal denstify function for this graph
p3 <- p2+stat_function(fun = dnorm, colour = 'red', args = list(mean = mu, sd = sigma))
library(grid)
library(gridExtra)
library(png) # those are packages we need to do it
install.packages('png')
library(grid)
library(gridExtra)
library(png) # those are packages we need to do it
grid.arrange(p1,p2,p3, ncol = 3)
ggplot()+aes(x)+geom_histogram(binwith = 1, colour = 'black',fill = '#1976D2', aes(y = ...density...))
ggplot()+aes(x)+geom_histogram(binwith = 1, colour = 'black',fill = '#1976D2', aes(y = ..density..))
ggplot()+aes(x)+geom_histogram(binwith = 1, colour = 'black',fill = '#1976D2', aes(y = ..density..))
ggplot()+aes(x)+geom_histogram(binwith = 1, colour = 'black',fill = '#1976D2', aes(y = ..density..)) +
stat_function(fun = dnorm, colour = 'red', args = list(mean = mu, sd = sigma))
spdj <- read_csv(file.choose())
head(spdj)
spdj <- read_csv(file = '/Users/Michael/Library/Mobile Documents/com~apple~CloudDocs/Economics/Financial Econometrics/Tutorial/T1/sp_dj.csv')
spdj$splnr <- c(NA, diff(log(spdj$SP500), lag = 1))
spdj$djlnr <- c(NA, diff(log(spdj$DJIA), lag = 1))
spdj
library(lubridate)
dmy(10.1.1975)
dmy('10.1.1975')
spdj$Date <- dmy(spdj$Date)
spdj
type(spdj)
typeof(spjd)
typeof(spdj)
typeof(spdj[,1:2])
head(spdj[,1:2])
head(spdj[,2:3])
typeof(spdj[-1,2:3])
head(spdj[-1,2:3])
'list' == 'list'
dim(spdj[,2:3])
dim(spdj[,2:3])[1]
typeof(spdj)
head(spdj[[2]])
names(spdj)
spdj
head(data.matrix(spdj[,2:3]))
typeof(data.matrix(spdj[,2:3]))
nmcol = dim(spdj)[2]
nmcol
1:nmcol
varnames <- c('a','b','c','d')
varnames
varnames[2:4]
for (var in varnames) {print(var)}
a = 'Date'
head(spdj$a)
a
data.frame(moment = c('mean', 'standard derivation', 'skewness', 'kurtosis'), var1 = c())
data.frame(moment = c('mean', 'standard derivation', 'skewness', 'kurtosis'))
head(spdj[,2])
library(moment)
library(moments)
install.packages('moments')
varnames
varnames <- names(spdj)[2:5]
varnames
momtable <- data.frame(moment = c('mean', 'standard derivation', 'skewness', 'kurtosis'))
momtable
momtable$varnames[1] <- c(1,2,3,4)
varnames[2]
noquote(varnames[2])
momtable$noquote(varnames[2])<- c(1,2,3,4)
cbind(momtable, c(1,2,3,4))
mymomentfun <- function(mtx){
if (typeof(mtx) == 'matrix'){
a = 1; # indicator of right format
}
else if (typeof(mtx == 'list')){
a = 1;
}
else {
a = 0; # indicator of wrong format
}
# defautly we assume that the first column is the Date
nmrow <- dim(mtx)[1]
nmcol <- dim(mtx)[2]
varnames <- names(mtx) # get the names of matrix
datanames <- varnames[2:nmcol] # the names of main variables we are interested
momtable <- data.frame(moment = c('mean', 'standard derivation', 'skewness', 'kurtosis')) # initialize a table first
library(moments)
for (i in 2:nmcol){
v_avg = mean(mtx[,i])
v_sd = sd(mtx[,i])
v_ske = skewness(mtx[,i])
v_kur = kurtosis(mtx[,i])
temp = c(v_avg, v_sd, v_ske, v_kur)
momtable <- cbind(momtable, temp)
}
names(momtable) <- datanames
return(momtable)
}
mymomentfun(spdj)
mymomentfun <- function(mtx){
# defautly we assume that the first column is the Date
nmrow <- dim(mtx)[1]
nmcol <- dim(mtx)[2]
varnames <- names(mtx) # get the names of matrix
datanames <- varnames[2:nmcol] # the names of main variables we are interested
momtable <- data.frame(moment = c('mean', 'standard derivation', 'skewness', 'kurtosis')) # initialize a table first
library(moments)
for (i in 2:nmcol){
v_avg = mean(mtx[,i])
v_sd = sd(mtx[,i])
v_ske = skewness(mtx[,i])
v_kur = kurtosis(mtx[,i])
temp = c(v_avg, v_sd, v_ske, v_kur)
momtable <- cbind(momtable, temp)
}
names(momtable) <- datanames
return(momtable)
}
mymomentfun(spdj)
mymomentfun <- function(mtx){
# defautly we assume that the first column is the Date
nmrow <- dim(mtx)[1]
nmcol <- dim(mtx)[2]
varnames <- names(mtx) # get the names of matrix
datanames <- varnames[2:nmcol] # the names of main variables we are interested
momtable <- data.frame(moment = c('mean', 'standard derivation', 'skewness', 'kurtosis')) # initialize a table first
library(moments)
for (i in 2:nmcol){
v_avg = mean(mtx[,i], na.rm = T)
v_sd = sd(mtx[,i], na.rm = T)
v_ske = skewness(mtx[,i], na.rm = T)
v_kur = kurtosis(mtx[,i], na.rm = T)
temp = c(v_avg, v_sd, v_ske, v_kur)
momtable <- cbind(momtable, temp)
}
names(momtable) <- datanames
return(momtable)
}
mymomentfun(spdj)
dim(spdj)[1]
head(spdj[,2])
nmrow <- dim(spdj)[1]
nmcol <- dim(spdj)[2]
varnames <- names(spdj) # get the names of matrix
datanames <- varnames[2:nmcol] # the names of main variables we are interested
momtable <- data.frame(moment = c('mean', 'standard derivation', 'skewness', 'kurtosis')) # initialize a table first
library(moments)
for (i in 2:nmcol){
v_avg = mean(spdj[,i], na.rm = T)
v_sd = sd(spdj[,i], na.rm = T)
v_ske = skewness(spdj[,i], na.rm = T)
v_kur = kurtosis(spdj[,i], na.rm = T)
temp = c(v_avg, v_sd, v_ske, v_kur)
momtable <- cbind(momtable, temp)
}
names(momtable) <- datanames
nmrow <- dim(spdj)[1]
nmcol <- dim(spdj)[2]
varnames <- names(spdj) # get the names of matrix
datanames <- varnames[2:nmcol] # the names of main variables we are interested
momtable <- data_frame(moment = c('mean', 'standard derivation', 'skewness', 'kurtosis')) # initialize a table first
library(moments)
for (i in 2:nmcol){
v_avg = mean(spdj[,i], na.rm = T)
v_sd = sd(spdj[,i], na.rm = T)
v_ske = skewness(spdj[,i], na.rm = T)
v_kur = kurtosis(spdj[,i], na.rm = T)
temp = c(v_avg, v_sd, v_ske, v_kur)
momtable <- cbind(momtable, temp)
}
names(momtable) <- datanames
nmrow <- dim(spdj)[1]
nmcol <- dim(spdj)[2]
varnames <- names(spdj) # get the names of matrix
datanames <- varnames[2:nmcol] # the names of main variables we are interested
momtable <- data_frame(moment = c('mean', 'standard derivation', 'skewness', 'kurtosis')) # initialize a table first
library(moments)
for (i in 2:nmcol){
v_avg = mean(spdj[,i], na.rm = T)
v_sd = sd(spdj[,i], na.rm = T)
v_ske = skewness(spdj[,i], na.rm = T)
v_kur = kurtosis(spdj[,i], na.rm = T)
temp = c(v_avg, v_sd, v_ske, v_kur)
temp = as.data.frame(temp)
momtable <- cbind(momtable, temp)
}
names(momtable) <- datanames
trym <= data_frame(ah = c('a','b','c','d'))
trym <- data_frame(ah = c('a','b','c','d'))
trym
temp
mean(spdj[,2])
mean(spdj[,2],na.rm = T)
spdj
head(spdj)
head(spdj[,2])
spdj <- as.data.frame(spdj)
typeof(spdj)
mean(spdj[,2],na.rm = T)
head(spdj)
nmrow <- dim(spdj)[1]
nmcol <- dim(spdj)[2]
varnames <- names(spdj) # get the names of matrix
datanames <- varnames[2:nmcol] # the names of main variables we are interested
momtable <- data_frame(moment = c('mean', 'standard derivation', 'skewness', 'kurtosis')) # initialize a table first
library(moments)
for (i in 2:nmcol){
v_avg = mean(spdj[,i], na.rm = T)
v_sd = sd(spdj[,i], na.rm = T)
v_ske = skewness(spdj[,i], na.rm = T)
v_kur = kurtosis(spdj[,i], na.rm = T)
temp = c(v_avg, v_sd, v_ske, v_kur)
temp = as.data.frame(temp)
momtable <- cbind(momtable, temp)
}
names(momtable) <- datanames
momtable
install.packages('igraph')
library(igraph)
c <- matrix(c(0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0),nrow = 4,byrow = F)
c
g <- graph.adjacency(c, mode = 'undirected', weighted = NULL)
g
plot(g)
P <- t(matrix(c( 0.7, 0.2, 0.1,
0.4, 0.6,   0,
0,   1,   0  ), nrow=3, ncol=3))
p
P
num.chains     <- 5
num.iterations <- 50
chain.states  <- matrix(NA, ncol=num.chains, nrow=num.iterations)
chain.states
run.mc.sim <- function( P, num.iters = 50 ) {
# number of possible states
num.states <- nrow(P)
# stores the states X_t through time
states     <- numeric(num.iters)
# initialize variable for first state
states[1]    <- 1
for(t in 2:num.iters) {
# probability vector to simulate next state X_{t+1}
p  <- P[states[t-1], ]
## draw from multinomial and determine state
states[t] <-  which(rmultinom(1, 1, p) == 1)
}
return(states)
}
for(c in seq_len(num.chains)){
chain.states[,c] <- run.mc.sim(P)
}
matplot(chain.states, type='l', lty=1, col=1:5, ylim=c(0,4), ylab='state', xlab='time')
abline(h=1, lty=3)
abline(h=3, lty=3)
clear
rm(list=ls())
rm(list = ls())
P <- t(matrix(c( 0.7, 0.2, 0.1,
0.4, 0.6,   0,
0,   1,   0  ), nrow=3, ncol=3))
P
nrow(P)
num.iters = 50
numeri(num.iters)
numeric(num.iters)
?numeric
numeric(5)
states = numeric(num.iters)
states[1] <- 1
2:10
states[1]
P[1,]
p = P[1,]
p
rmultinom(1,1,p)
rmultinom(1,2,p)
rmultinom(2,5,p)
rmultinom(2,1,p)
rmultinom(1,7,p)
p
rmultinom(1,10,p)
rmultinom(1,16,p)
rmultinom(1,1,p)
rmultinom(1,1,p)
rmultinom(1,1,p)
rmultinom(1,1,p)
rmultinom(1,1,p)
rmultinom(1,1,p)
which(rmultinom(1,1,p))
which(rmultinom(1,1,p) == 1)
rm(apply(ls()))
rm(ls(apply))
rm(list = ls())
library(tidyverse)
data = read.csv(file.choose(), header = T)
head(data)
libra
library(tidyverse)
souvk <- read_csv(file.choose())
head(souvk)
View(souvk)
View(souvk)
library(lubridate)
souvk$date2 <- mdy(souvk$date)
head(souvk)
View(souvk)
View(souvk)
write_csv(souvk, path = '/Users/Michael/Desktop/souv_bee_data.csv')
log(10)
log(1.5)
log(0.6)
e^(-310)
exp(-310)
log(0.3)
log(0.2)
log(0.02)
log(0.006)
log(0.8)
log(0.9)
log(0.6)
log(0.8)
log(0.7)
log(0.68)
log(0.79)
log(0.62)
log(0.4)
log(0.59)
1.03^(-0.25)
60.5/68.5*1.4+8/68.5
2*(2472.526 - 2467.689)
2*(1152.517-1149.998)
library(igraph)
g <- graph.formula(1-2, 2-3, 2-4, 3-4)
V(g) # gives the sequences of nodes
E(g) # gives the sequences of edge
s <- graph.formula(A-B, B-C, C-D, B-D) # we can use alphabet to represent nodes
str(g) # shows the structure of network
str(s)
plot(g)
plot(s)
# we can change the color and size of nodes (vertes)
V(g)$size <- 16
V(g)$color <- "#8ABCDD"
plot(g)
E(s)$width <- 1.6
E(g)$width <- 1.6
E(s)$color <- "black"
E(g)$color <- "black"
# plot two figures side by sdie
par(mfrow = c(1,2))
plot(g, layout=layout.auto, main = "Figure 2.11")
plot(s, layout = layout.auto, main = "Figure 2.22")
# add one plot with directions
dg <-graph.formula( A -+ B, B -+ C, C -+ D, D -+ B)
plot(dg)
# change the arrow size
E(dg)$arrow.size <- 0.3
E(dg)$color <- "black"
V(dg)$color <- "white"
plot(dg)
par(mfrow = c(1,3))
plot(g, layout=layout.auto)
title("Figure 2.11", line = -5)
plot(s, layout = layout.auto)
title("Figure 2.12", line = -5)
plot(dg, layout = layout.auto)
title("Figure 2.13", line = -5)
pwd
pwd
getwd
getwd()
setwd("~/Documents")
getwd()
setwd("~/Documents/Network_Analysis")
getwd()
g <- matrix(c(0, 1, 0, 1, 0, 1, 0, 1, 0), byrow = T)
g
g <- matrix(c(0, 1, 0, 1, 0, 1, 0, 1, 0), nrow = 3, byrow = T)
g
graph_from_adjacency_matrix(g)
library(igraph)
graph_from_adjacency_matrix(g)
gg <- graph_from_adjacency_matrix(g)
plot(gg)
gg <- graph_from_adjacency_matrix(g, mode = "undirected" )
plot(gg)
g2 <- matrix(c(0, 0, 0, 1, 0, 1, 0, 1, 0), nrow = 3, byrow = T)
gg2 <- graph_from_adjacency_matrix(g2) # default mode = undirected
plot(gg2)
g2
V(gg)$color <- "#649EFC"
plot(gg)
V(gg)$color <- "#78C8A5"
plot(gg)
g2 <- matrix(c(0, 0, 0, 1, 0, 1, 0, 1, 0), nrow = 3, byrow = T)
gg2 <- graph_from_adjacency_matrix(g2) # default mode = undirected
plot(gg2)
par(bg = 'grey')
plot(gg2)
par(bg = "#868686")
plot(gg2)
par(bg = "lightgrey")
plot(gg2)
plot(gg)
par(bg = "#EBEBEB")
plot(gg2)
plot(gg)
plot(gg2)
g3 = matrix(c(0, 1 , 1, 0, 1, 0 , 0, 1, 1, 0, 0, 1, 0, 1, 1, 0), nrow = 4, byrow = T)
gg3 <- graph_from_adjacency_matrix(gg3, mode = "undirected")
plot(gg3)
g3 = matrix(c(0, 1 , 1, 0, 1, 0 , 0, 1, 1, 0, 0, 1, 0, 1, 1, 0), nrow = 4, byrow = T)
gg3 <- graph_from_adjacency_matrix(g3, mode = "undirected")
plot(gg3)
